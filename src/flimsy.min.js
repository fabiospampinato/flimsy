var o,i,u=!1,a=Symbol(),r=class{static wrap(t,e,s){let h=i,b=u;i=e,u=s;try{return t()}catch(p){let d=e?.get(a);if(d)d.forEach(v=>v(p));else throw p}finally{i=h,u=b}}},c=class{constructor(t,{equals:e}={}){this.observers=new Set;this.get=()=>(u&&i instanceof l&&(this.observers.add(i),i.signals.add(this)),this.parent?.waiting&&this.parent.update(),this.value);this.set=t=>{let e=t instanceof Function?t(this.value):t;return this.equals(this.value,e)||(o?o.set(this,e):(this.value=e,this.stale(1,!0),this.stale(-1,!0))),this.value};this.stale=(t,e)=>{this.observers.forEach(s=>{s.stale(t,e)})};this.value=t,this.equals=e===!1?()=>!1:e||Object.is}},T=class{constructor(){this.parent=i;this.cleanups=[];this.contexts={};this.observers=new Set;this.signals=new Set;this.dispose=()=>{this.observers.forEach(t=>{t.dispose()}),this.signals.forEach(t=>{t.observers.delete(this)}),this.cleanups.forEach(t=>{t()}),this.cleanups=[],this.contexts={},this.observers=new Set,this.signals=new Set,this.parent?.observers.delete(this)};this.get=t=>t in this.contexts?this.contexts[t]:this.parent?.get(t);this.set=(t,e)=>{this.contexts[t]=e}}},f=class extends T{wrap(t){let e=()=>t(this.dispose);return r.wrap(e,this,!1)}},l=class extends T{constructor(e,s){super();this.waiting=0;this.fresh=!1;this.run=()=>(this.dispose(),this.parent?.observers.add(this),r.wrap(this.fn,this,!0));this.update=()=>{this.waiting=0,this.fresh=!1,this.signal.set(this.run)};this.stale=(e,s)=>{!this.waiting&&e<0||(!this.waiting&&e>0&&this.signal.stale(1,!1),this.waiting+=e,this.fresh||(this.fresh=s),this.waiting||(this.waiting=0,this.fresh&&this.update(),this.signal.stale(-1,!1)))};this.fn=e,this.signal=new c(this.run(),s),this.signal.parent=this}};function g(n,t){let{get:e,set:s}=new c(n,t);return[e,s]}function w(n){new l(n)}function C(n,t){return new l(n,t).signal.get}function y(n){return new f().wrap(n)}function x(n){let t=Symbol();return{id:t,defaultValue:n,get:()=>i?.get(t)??n,set:h=>i?.set(t,h)}}function E(n){return n.get()}function S(n){i?.cleanups.push(n)}function k(n){var t;i&&((t=i.contexts)[a]||(t[a]=[]),i.contexts[a].push(n))}function F(n){if(o)return n();let t=o=new Map;try{return n()}finally{o=void 0,t.forEach((e,s)=>s.stale(1,!1)),t.forEach((e,s)=>s.set(()=>e)),t.forEach((e,s)=>s.stale(-1,!1))}}function O(n){return r.wrap(n,i,!1)}export{F as batch,x as createContext,w as createEffect,C as createMemo,y as createRoot,g as createSignal,S as onCleanup,k as onError,O as untrack,E as useContext};
